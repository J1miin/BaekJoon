/*
n으로 나눴을 때 나머지와 몫이 똑같은 자연수의 합을 구하기
ex. n=3 
8 /3=2...2
8=3*2+2
4=3*1+1
k=N*(a)+a
a<=N-1
---
n=4
4x1+1=5
4x2+2=10
4x3+3=15
4
----

n=5
6,12,18,24 
n=N이면, a1=N+1이고 공차도 N+1인 N-1개의 수열의 합
an-1= a1+(n-2)d 
Sn-1= (a1 + an-1)*(n-1)/2
########################################################################
개념 : 귀납적으로 풀다보니 등차수열의 합공식이 적용됨을 발견할 수 있었다.
자료구조 : 그냥 수학 공식으로 계산해서 따로 자료구조는 없음. long long 타입을 써야했다는 것 
-> overflow 방지
예상하는 시간 복잡도 : 단순 산술 계산이므로 n이 커져도 반복문 없어서 연산 횟수는 5번으로 일정함 -> O(1) 
공간 복잡도 : 변수가 네 개고, N에 따라 메모리 사용량이 변하지 않으므로 상수 공간 복잡도이다. O(1)
**TIP : 공간복잡도의 경우 입력 크기에 따라 변하는 데이터 구조가 있는가?를 생각하자
반복문 없이 변수를 몇 개만 사용 → O(1)
배열, 리스트, 해시맵 등을 사용 → 크기에 따라 O(N) 이상
2차원 배열을 사용 → O(N²)
재귀 함수 → O(재귀 깊이) → 보통 O(N) 또는 O(log N)
########################################################################
*/
#include <iostream>
using namespace std;
//등차수열의 합 공식 사용하기
int main(){
    ios::sync_with_stdio(0); cin.tie(0); 
    long long iN, iA1, iAn_1, iResult; //오버플로우가 발생하니까 long long 써야한다.
    cin >> iN;
    iA1 = iN+1;
    iAn_1 = iA1 + (iN-2)*(iN+1);
    iResult = (iA1+iAn_1)*(iN-1)/2;
    cout<<iResult<<endl;

    return 0;
}